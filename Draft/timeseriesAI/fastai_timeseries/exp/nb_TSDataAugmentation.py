#AUTOGENERATED! DO NOT EDIT! file to edit: ./TSDataAugmentation.ipynb (unless otherwise specified)

import copy
import numpy as np
import random
from functools import partial


try: from exp.nb_TSUtilities import *
except ImportError: from .nb_TSUtilities import *


def shuffle_HLs(ts, **kwargs):
    line = copy(ts)
    pos_rand_list = np.random.choice(
        np.arange(ts.shape[-1] // 4),
        size=random.randint(0, ts.shape[-1] // 4),
        replace=False)
    rand_list = pos_rand_list * 4
    highs = rand_list + 1
    lows = highs + 1
    a = np.vstack([highs, lows]).flatten('F')
    b = np.vstack([lows, highs]).flatten('F')
    line[..., a] = line[..., b]
    return line

setattr(shuffle_HLs, 'use_on_y', False)


def window_slice(a, α=.9, **kwargs):
    if α == 1.0: return a
    new_a = a.clone()
    seq_len = new_a.shape[-1]
    win_len = int(seq_len * α)
    start = np.random.randint(0, seq_len - win_len)
    new_a = new_a[:, start : start + win_len]
    return new_a

setattr(window_slice, 'use_on_y', False)


def channelout(a, α=1):
    new_a = a.clone()
    input_ch = new_a.shape[0]
    out_ch = np.random.choice(np.arange(input_ch), int(np.random.beta(α, 1) * input_ch), replace=False)
    new_a[out_ch] = 0
    return new_a

setattr(channelout, 'use_on_y', False)


def mult_scale(a, α=.2):
    mult = (np.random.rand() - .5) * 2 * α
    new_a = a.clone()
    return new_a * (1 + mult)

setattr(mult_scale, 'use_on_y', False)


def rand_lookback(a, α=2., β=.75):
    new_a = a.clone()
    lookback_per = int(np.random.beta(1, α) * new_a.shape[-1] * β)
    new_a[:, :lookback_per] = 0
    return new_a

setattr(rand_lookback, 'use_on_y', False)




def rotate_ch(a):
    new_a = a.clone()
    n_ch = new_a.shape[-2]
    ch_order = np.random.choice(np.arange(n_ch), n_ch, replace=False)
    new_a = new_a[ch_order]
    return new_a

setattr(rotate_ch, 'use_on_y', False)


def get_diff(a):
    return np.concatenate((np.zeros(a.shape[-2])[:, None], np.diff(a)), axis=1).astype(np.float32)

setattr(get_diff, 'use_on_y', False)


def XYaug(tensor, x_perc=.1, y_perc=.1, num_masks=1, replace_with='mean', same_xy=False, **kwargs):
    # x_perc and y_perc must be a float or int

    tensor = ToTensor(tensor)
    len_x = tensor.shape[-1]
    len_y = tensor.shape[-2]
    if x_perc >= 1: x_perc = x_perc / 100
    X = int(len_x * x_perc)
    if y_perc >= 1: y_perc = y_perc / 100
    Y = int(len_y * y_perc)
    if X == 0 and Y == 0: return tensor
    assert replace_with in(['zero', 'mask_mean', 'mean']), \
        "select a valid replace_with value! ('zero', 'mask_mean', 'mean')"
    if same_xy and len_x != len_y:
        assert same_xy == False, 'tensor is not squared. Change same_xy to False'
        assert replace_with != 'mask_mean', 'same_xy, choose mean or zero replace_with'
    if replace_with == 'zero': mask_value = 0
    elif replace_with == 'mean': mask_value = tensor.mean()
    cloned = tensor.clone().float()
    for i in range(0, num_masks):
        if X != 0:
            x = random.randrange(0, X)
            if x != 0:
                x_zero = random.randrange(0, len_x - x)
                if replace_with == 'mask_mean': mask_value = tensor[:, x_zero:x_zero + x].mean()
                cloned[..., x_zero:x_zero + x] = mask_value
                if same_xy:
                    cloned[..., x_zero:x_zero + x, :] = mask_value
                    Y = 0
        if Y != 0:
            y = random.randrange(0, Y)
            if y != 0:
                y_zero = random.randrange(0, len_y - y)
                if replace_with == 'mask_mean': mask_value = tensor[y_zero:y_zero + y].mean()
                cloned[..., y_zero:y_zero + y, :] = mask_value
    return cloned

xyaug = partial(XYaug)


def warp1d(ts, wtype='lin', kind='linear', comp=20):
    # wtype: lin, geo
    # kind: 'linear', 'nearest', 'slinear', 'zero', 'slinear', 'quadratic', 'cubic'
    tsa = To2dArray(ts)
    seq_len = tsa.shape[-1]
    f = scipy.interpolate.interp1d(
        np.arange(seq_len),
        tsa,
        kind=kind,
        axis=-1,
        copy=True,
        bounds_error=None,
        assume_sorted=False)
    x_coord = np.random.randint(1, seq_len)
    #x_coord = normal_choice(np.arange(1, seq_len))
    comp_factor = np.random.randint(100 - comp, 101 + comp) / 100
    steps = max(0, min(seq_len, int(x_coord * comp_factor)))
    if wtype == 'lin': new_x = np.linspace(0, x_coord, steps)
    else: new_x = np.geomspace(1, x_coord + 1, steps) - 1
    if len(new_x) < seq_len:
        if wtype == 'lin': new_x = np.append(new_x, np.linspace(x_coord, seq_len - 1, seq_len - steps + 1)[1:])
        else: new_x = np.append(new_x, np.geomspace(x_coord, seq_len - 1, seq_len - steps + 1)[1:])
    new_x = np.clip(new_x, 0, seq_len - 1)
    new_y = f(new_x)
    return ts.new(new_y)

setattr(warp1d, 'use_on_y', False)

def warp_noise(ts, kind='linear'):
    # kind: 'linear', 'nearest', 'slinear', 'zero', 'slinear', 'quadratic', 'cubic'
    tsa = To2dArray(ts)
    seq_len = tsa.shape[-1]
    f = scipy.interpolate.interp1d(
        np.arange(seq_len),
        tsa,
        kind=kind,
        axis=-1,
        copy=True,
        bounds_error=None,
        assume_sorted=False)
    new_x = np.clip(get_noisy_x(seq_len), 0, seq_len - 1)
    new_y = f(new_x)
    return ts.new(new_y)

setattr(warp_noise, 'use_on_y', False)

def warp_peak_ts(ts, wtype='lin', kind='linear', comp=20):
    # wtype: lin, geo
    # kind: 'linear', 'nearest', 'slinear', 'zero', 'slinear', 'quadratic', 'cubic'
    tsa = To2dArray(ts)
    seq_len = tsa.shape[-1]
    f = scipy.interpolate.interp1d(
        np.arange(seq_len),
        tsa,
        kind=kind,
        axis=-1,
        copy=True,
        bounds_error=None,
        assume_sorted=False)
    x_coord = max(1, np.argmax(tsa.max(axis=0)))
    comp_factor = np.random.randint(100 - comp, 101 + comp) / 100
    steps = max(0, min(seq_len, int(x_coord * comp_factor)))
    if wtype=='lin': new_x = np.linspace(0, x_coord, steps)
    else: new_x = np.geomspace(1, x_coord + 1, steps) - 1
    if steps < seq_len:
        if wtype=='lin': new_x = np.append(new_x, np.linspace(x_coord, seq_len - 1, seq_len - steps + 1)[1:])
        else: new_x = np.append(new_x, np.geomspace(x_coord, seq_len - 1, seq_len - steps + 1)[1:])
    new_x = np.clip(new_x, 0, seq_len - 1)
    new_y = f(new_x)
    return ts.new(new_y)

setattr(warp_peak_ts, 'use_on_y', False)

def get_noisy_x(seq_len):
    noise = np.sort(np.random.rand(seq_len))
    noise = (noise - noise.min())
    noise = (noise / noise.max()) * (seq_len - 1)
    return noise


from random import normalvariate


def normal_choice(lst, mean=None, stddev=None):
    if mean is None:
        # if mean is not specified, use center of list
        mean = (len(lst) - 1) / 2
    if stddev is None:
        # if stddev is not specified, let list be -3 .. +3 standard deviations
        stddev = len(lst) / 6
    while True:
        index = int(normalvariate(mean, stddev) + 0.5)
        if 0 <= index < len(lst):
            return lst[index]