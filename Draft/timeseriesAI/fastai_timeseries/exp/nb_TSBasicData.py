#AUTOGENERATED! DO NOT EDIT! file to edit: ./TSBasicData.ipynb (unless otherwise specified)
import fastai
from fastai.torch_core import *
from fastai.basic_data import *
from fastai.data_block import *
from fastai.core import *


try:
    from exp.nb_TSUtilities import *
    from exp.nb_TSDatasets import *
except ImportError:
    from .nb_TSUtilities import *
    from .nb_TSDatasets import *


class TimeSeriesItem(ItemBase):
    "`ItemBase` suitable for time series"

    def __init__(self, item, *args, **kwargs):
        super().__init__(item, *args, **kwargs)
        self.data = item
        self.obj = item
        self.channels = item.shape[-2]
        self.seq_len = item.shape[-1]


    def __str__(self):
        return 'TimeSeries(ch={:.0f}, seq_len={:.0f})'.format(
            self.channels, self.seq_len)

    def clone(self):
        return self.__class__(self.data.clone())

    def apply_tfms(self, tfms, **kwargs):
        x = self.clone()
        for tfm in tfms:
            x.data = tfm(x.data)
        return x

    def reconstruct(self, item):
        return TimeSeriesItem(item)

    def show(self, ax=None, title=None, **kwargs):
        if ax is None:
            plt.plot(self.data.transpose_(0, 1))
            plt.show()
        else:
            ax.plot(self.data.transpose_(0, 1))
            ax.title.set_text(title)
            ax.tick_params(
                axis='both',
                which='both',
                bottom='off',
                top='off',
                labelbottom='off',
                right='off',
                left='off',
                labelleft='off')
            return ax


def get_class_weights(target):
    if isinstance(target, np.ndarray): target = torch.Tensor(target).to(dtype=torch.int64)
    # Compute samples weight (each sample should get its own weight)
    class_sample_count = torch.tensor(
        [(target == t).sum() for t in torch.unique(target, sorted=True)])
    weights = 1. / class_sample_count.float()
    return (weights / weights.sum()).to(device)


class TSDataBunch(DataBunch):


    def get_stats(self):
        train = To3dArray(self.label_list.train.items)
        if self.type == 'normalize':
            if self.subtype == 'all_samples':
                train_min = train.min(keepdims=True)
                train_max = train.max(keepdims=True)
            elif self.subtype == 'per_sample':
                train_min = train.min(axis=(1, 2), keepdims=True)
                train_max = train.max(axis=(1, 2), keepdims=True)
            elif self.subtype == 'per_channel':
                train_min = train.min(axis=(0, 2), keepdims=True)
                train_max = train.max(axis=(0, 2), keepdims=True)
            else:
                print('***** Please, select a valid  scaling_subtype *****')
                return
            self.min, self.max = train_min, train_max
            return self

        elif self.type == 'standardize':
            if self.subtype == 'all_samples':
                train_mean = train.mean(keepdims=True)
                train_std = train.std(keepdims=True)
            elif self.subtype == 'per_sample':
                train_mean = train.mean(axis=(1, 2), keepdims=True)
                train_std = train.std(axis=(1, 2), keepdims=True)
            elif self.subtype == 'per_channel':
                train_mean = train.mean(axis=(0, 2), keepdims=True)
                train_std = train.std(axis=(0, 2), keepdims=True)
            else:
                print('***** Please, select a valid  scaling_subtype *****')
                return
            self.mean, self.std = train_mean, train_std
            return self

        else:
            print('***** Please, select a valid  scaling_type *****')
            return

    def scale(self, scale_type='standardize', scale_subtype='per_channel', scale_range=(-1, 1)) -> None:
        self.type = scale_type
        self.subtype = scale_subtype
        self.range = scale_range
        self.get_stats()
        if self.type == 'standardize':
            self.label_list.train.x.items = (self.label_list.train.x.items -
                                             self.mean) / self.std
            self.label_list.valid.x.items = (self.label_list.valid.x.items -
                                             self.mean) / self.std
            if self.label_list.test is not None:
                self.label_list.test.x.items = (self.label_list.test.x.items -
                                                self.mean) / self.std
            return self
        elif self.type == 'normalize':
            self.label_list.train.x.items = (
                ((self.label_list.train.x.items - self.min)) /
                (self.max - self.min)) * (self.range[1] - self.range[0]) + self.range[0]
            self.label_list.valid.x.items = (
                ((self.label_list.valid.x.items - self.min)) /
                (self.max - self.min)) * (self.range[1] - self.range[0]) + self.range[0]
            if self.label_list.test is not None:
                self.label_list.test.x.items = (
                    ((self.label_list.test.x.items - self.min)) /
                    (self.max - self.min)) * (self.range[1] - self.range[0]) + self.range[0]
            return self
        else: return print('Select a correct type', self.type)



class TSPreProcessor(PreProcessor):

    def __init__(self, ds: ItemList): self.ds = ds

    def process(self, ds: ItemList):
        ds.features, ds.seq_len = self.ds.get(0).data.size(-2), self.ds.get(0).data.size(-1)


class TimeSeriesList(ItemList):
    "`ItemList` suitable for time series"
    _bunch = TSDataBunch
    _processor = TSPreProcessor
    _label_cls = None
    _square_show = True

    def __init__(self, items, *args, mask=None, tfms=None, **kwargs):
        items = To3dTensor(items)
        super().__init__(items, *args, **kwargs)
        self.tfms,self.mask = tfms,mask
        self.copy_new.append('tfms')

    def get(self, i):
        item = super().get(i)
        if self.mask is None: return TimeSeriesItem(To2dTensor(item))
        else: return[TimeSeriesItem(To2dTensor(item[m])) for m in self.mask]


    def show_xys(self, xs, ys, figsize=(10, 10), **kwargs):
        "Show the `xs` and `ys` on a figure of `figsize`. `kwargs` are passed to the show method."
        rows = int(math.sqrt(len(xs)))
        fig, axs = plt.subplots(rows, rows, figsize=figsize)
        for x, y, ax in zip(xs, ys, axs.flatten()):
            x.show(ax=ax, title=str(y), **kwargs)
        plt.tight_layout()
        plt.show()

    def show_xyzs(self, xs, ys, zs, figsize=(10, 10), **kwargs):
        if self._square_show_res:
            rows = int(np.ceil(math.sqrt(len(xs))))
            fig, axs = plt.subplots(
                rows,
                rows,
                figsize=figsize,
                title='Ground truth\nPredictions',
                weight='bold',
                size=12)
            for x, y, z, ax in zip(xs, ys, zs, axs.flatten()):
                x.show(ax=ax, title=f'{str(y)}\n{str(z)}', **kwargs)
        else:
            fig, axs = plt.subplots(
                len(xs),
                2,
                figsize=figsize,
                title='Ground truth/Predictions',
                weight='bold',
                size=12)
            for i, (x, y, z) in enumerate(zip(xs, ys, zs)):
                x.show(ax=axs[i, 0], title=str(y), **kwargs)
                x.show(ax=axs[i, 1], title=str(z), **kwargs)
        plt.tight_layout()
        plt.show()

    @classmethod
    def from_array(cls, ts, **kwargs):
        return cls(ts)

    @classmethod
    def from_df(cls, df, path='.', cols=None, feat=None, processor=None, **kwargs) -> 'ItemList':
        "Create an `ItemList` in `path` from the inputs in the `cols` of `df`."
        if cols is 0:
            inputs = df
        else:
            col_idxs = df_names_to_idx(list(cols), df)
            inputs = df.iloc[:, col_idxs]
        assert inputs.isna().sum().sum(
        ) == 0, f"You have NaN values in column(s) {cols} of your dataframe, please fix it."
        inputs = df2array(inputs, feat)
        res = cls(
            items=inputs,
            path=path,
            inner_df=df,
            processor=processor,
            **kwargs)
        return res



class MixedTimeSeriesList(ItemList):
    "`ItemList` suitable for time series"
    _bunch = TSDataBunch
    _processor = TSPreProcessor
    _label_cls = None
    _square_show = True

    def __init__(self, items, *args, mask=None, tfms=None, **kwargs):
        items = To3dTensor(items)
        super().__init__(items, *args, **kwargs)
        self.tfms,self.mask = tfms,mask
        self.copy_new.append('tfms')

    def get(self, i):
        item = super().get(i)
        if self.mask is None: return TimeSeriesItem(To2dTensor(item))
        else: return[TimeSeriesItem(To2dTensor(item[m])) for m in self.mask]


    def show_xys(self, xs, ys, figsize=(10, 10), **kwargs):
        "Show the `xs` and `ys` on a figure of `figsize`. `kwargs` are passed to the show method."
        rows = int(math.sqrt(len(xs)))
        fig, axs = plt.subplots(rows, rows, figsize=figsize)
        for x, y, ax in zip(xs, ys, axs.flatten()):
            x.show(ax=ax, title=str(y), **kwargs)
        plt.tight_layout()
        plt.show()

    def show_xyzs(self, xs, ys, zs, figsize=(10, 10), **kwargs):
        if self._square_show_res:
            rows = int(np.ceil(math.sqrt(len(xs))))
            fig, axs = plt.subplots(
                rows,
                rows,
                figsize=figsize,
                title='Ground truth\nPredictions',
                weight='bold',
                size=12)
            for x, y, z, ax in zip(xs, ys, zs, axs.flatten()):
                x.show(ax=ax, title=f'{str(y)}\n{str(z)}', **kwargs)
        else:
            fig, axs = plt.subplots(
                len(xs),
                2,
                figsize=figsize,
                title='Ground truth/Predictions',
                weight='bold',
                size=12)
            for i, (x, y, z) in enumerate(zip(xs, ys, zs)):
                x.show(ax=axs[i, 0], title=str(y), **kwargs)
                x.show(ax=axs[i, 1], title=str(z), **kwargs)
        plt.tight_layout()
        plt.show()

    @classmethod
    def from_array(cls, ts, processor=None, **kwargs):
        return cls(ts, processor=processor, **kwargs)

    @classmethod
    def from_df(cls, df, path='.', cols=None, feat=None, processor=None, **kwargs) -> 'ItemList':
        "Create an `ItemList` in `path` from the inputs in the `cols` of `df`."
        if cols is 0:
            inputs = df
        else:
            col_idxs = df_names_to_idx(list(cols), df)
            inputs = df.iloc[:, col_idxs]
        assert inputs.isna().sum().sum(
        ) == 0, f"You have NaN values in column(s) {cols} of your dataframe, please fix it."
        inputs = df2array(inputs, feat)

        res = cls(
            items=inputs,
            path=path,
            inner_df=df,
            processor=processor,
            **kwargs)
        return res


def df2array(df, feat=None):
    if feat is None:
        return df.values[:, None]
    for i, ch in enumerate(df[feat].unique()):
        data_i = df[df[feat] == ch].values[:, None]
        if i == 0: data = data_i
        else: data = np.concatenate((data, data_i), axis=1)
    return data